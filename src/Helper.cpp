#include "Helper.hpp"

#include <stdexcept>
#include <fstream>
#include <streambuf>
#include <iostream>
#include <boost/filesystem.hpp>
#include <orocos_cpp/Bundle.hpp>
#include <orocos_cpp/YAMLConfiguration.hpp>
#include <orocos_cpp/Configuration.hpp>
#include <orocos_cpp/ConfigurationHelper.hpp>

void Helper::writeTrajectory(const std::vector< base::Trajectory > &trajectory, const std::string& fullPath)
{
    if (!boost::filesystem::exists(fullPath))
        std::runtime_error("file does not exist");

    RTT::types::TypekitRepository::getTransports();
    RTT::types::TypeInfoRepository::shared_ptr ti = RTT::types::TypeInfoRepository::Instance();
    RTT::types::TypeInfo* type = ti->type("/std/vector</base/Trajectory>");
    if (! type)
    {
        throw std::runtime_error("cannot find /std/vector</base/Trajectory> in the type info repository");
    }

    orogen_transports::TypelibMarshallerBase* transport = dynamic_cast<orogen_transports::TypelibMarshallerBase*>(type->getProtocol(orogen_transports::TYPELIB_MARSHALLER_ID));
    if (! transport)
    {
        throw std::runtime_error(std::string("cannot report ports of type ") + type->getTypeName() + std::string(" as no typekit generated by orogen defines it"));
    }

    std::vector< u_int8_t > data;
    orogen_transports::TypelibMarshallerBase::Handle* handle =  transport->createSample();
    transport->setOrocosSample(handle, (void *)&trajectory);
    transport->marshal(data, handle);
    transport->refreshTypelibSample(handle);

    std::ofstream file(fullPath);
    file.write(reinterpret_cast<char const *>(data.data()), data.size());
}

void Helper::readTrajectory(std::vector< base::Trajectory > &trajectory, const std::string& fullPath)
{
    if (!boost::filesystem::exists(fullPath))
        std::runtime_error("file does not exist");

    std::ifstream stream(fullPath, std::ios::in | std::ios::binary);
    std::string str((std::istreambuf_iterator<char>(stream)), std::istreambuf_iterator<char>());
    std::vector< u_int8_t > data(str.begin(), str.end());

    std::cout << "Helper::readTrajectory: data.size() = " << data.size() << std::endl;

    RTT::types::TypekitRepository::getTransports();
    RTT::types::TypeInfoRepository::shared_ptr ti = RTT::types::TypeInfoRepository::Instance();
    RTT::types::TypeInfo* type = ti->type("/std/vector</base/Trajectory>");
    if (! type)
    {
        throw std::runtime_error("cannot find /std/vector</base/Trajectory> in the type info repository");
    }

    orogen_transports::TypelibMarshallerBase* transport = dynamic_cast<orogen_transports::TypelibMarshallerBase*>(type->getProtocol(orogen_transports::TYPELIB_MARSHALLER_ID));
    if (! transport)
    {
        throw std::runtime_error(std::string("cannot report ports of type ") + type->getTypeName() + std::string(" as no typekit generated by orogen defines it"));
    }

    orogen_transports::TypelibMarshallerBase::Handle* handle =  transport->createSample();
    transport->setOrocosSample(handle, (void *)&trajectory);
    transport->unmarshal(data, handle);
    transport->refreshOrocosSample(handle);
}

void Helper::readTrajectories(std::map< std::string, std::vector< base::Trajectory > > &trajectories, const std::string& dir)
{
    trajectories.clear();
    boost::filesystem::path directory(dir);
    boost::filesystem::directory_iterator endIter;

    if (!boost::filesystem::exists(directory) || !boost::filesystem::is_directory(directory))
        std::runtime_error("log folder does not exist");

    for (boost::filesystem::directory_iterator dirIter(directory); dirIter != endIter; dirIter++) {
        if (boost::filesystem::is_regular_file(dirIter->status())) {
            std::string fullPath = dir + std::string("/") + dirIter->path().filename().string();

            try {
                std::vector< base::Trajectory > trajectory;
                readTrajectory(trajectory, fullPath);
                if (!trajectory.empty())
                    trajectories[fullPath] = trajectory;
            } catch (...) {
                std::cout << "readTrajectories: " << fullPath << "not found.." << std::endl;
            }
        }
    }
}

void Helper::updateConfig(const std::map< std::string, double > &confVals, const std::string &controllerConfigName)
{
    std::string confDir = orocos_cpp::Bundle::getInstance().getConfigurationDirectory();
    std::string fullPath = confDir + std::string("trajectory_follower::Task.yml");
    orocos_cpp::YAMLConfigParser yamlParser;
    std::map<std::string, orocos_cpp::Configuration> subConfigs, newConfigs;
    yamlParser.loadConfigFile(fullPath, subConfigs);

    for (auto conf: subConfigs) {
        std::map<std::string, std::shared_ptr<orocos_cpp::ConfigValue> > confValues = conf.second.getValues();
        for (auto vals: confValues) {
            if (vals.second->getType() == orocos_cpp::ConfigValue::Type::COMPLEX) {
                orocos_cpp::ComplexConfigValue *configValue = dynamic_cast< orocos_cpp::ComplexConfigValue * >(vals.second.get());
                const std::map< std::string, std::shared_ptr< orocos_cpp::ConfigValue > > subConfValues = configValue->getValues();

                for (auto subVals: subConfValues) {
                    std::cout << "subConfigs value: " << subVals.first << std::endl;
                    if (subVals.first == controllerConfigName) {
                        if (subVals.second->getType() == orocos_cpp::ConfigValue::Type::COMPLEX) {
                            orocos_cpp::ComplexConfigValue *subConfigValue = dynamic_cast< orocos_cpp::ComplexConfigValue * >(subVals.second.get());
                            const std::map< std::string, std::shared_ptr< orocos_cpp::ConfigValue > > subSubConfValues = subConfigValue->getValues();

                            for (auto subSubVals: subSubConfValues) {
                                auto confValsIter = confVals.find(subSubVals.first);
                                if (subSubVals.second->getType() == orocos_cpp::ConfigValue::Type::SIMPLE && confValsIter != confVals.end()) {
                                    orocos_cpp::SimpleConfigValue *subSubConfigValue = dynamic_cast< orocos_cpp::SimpleConfigValue * >(subSubVals.second.get());
				    std::cout << "subSubVals: " << subSubVals.first << ", " << subSubConfigValue->getValue() << std::endl;
                                    std::shared_ptr< orocos_cpp::SimpleConfigValue > newValue(new orocos_cpp::SimpleConfigValue(std::to_string(confValsIter->second)));
                                    newValue->setName(subSubVals.first);
				    subSubConfigValue->merge(newValue);
                                    std::cout << "after merge: " << subSubVals.first << ", " << subSubConfigValue->getValue() << std::endl;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}